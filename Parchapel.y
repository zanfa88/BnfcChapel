-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parchapel where
import Abschapel
import Lexchapel
import ErrM

}

%attributetype      {MyAttribute a}
%attribute parsetree  {a}

%name pProgram Program

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token
 '!=' { PT _ (TS _ 1) }
 '#' { PT _ (TS _ 2) }
 '%' { PT _ (TS _ 3) }
 '&' { PT _ (TS _ 4) }
 '&&' { PT _ (TS _ 5) }
 '(' { PT _ (TS _ 6) }
 ')' { PT _ (TS _ 7) }
 '*' { PT _ (TS _ 8) }
 '+' { PT _ (TS _ 9) }
 ',' { PT _ (TS _ 10) }
 '-' { PT _ (TS _ 11) }
 '..' { PT _ (TS _ 12) }
 '/' { PT _ (TS _ 13) }
 ':' { PT _ (TS _ 14) }
 ';' { PT _ (TS _ 15) }
 '<' { PT _ (TS _ 16) }
 '<<' { PT _ (TS _ 17) }
 '<=' { PT _ (TS _ 18) }
 '=' { PT _ (TS _ 19) }
 '==' { PT _ (TS _ 20) }
 '>' { PT _ (TS _ 21) }
 '>=' { PT _ (TS _ 22) }
 '>>' { PT _ (TS _ 23) }
 '[' { PT _ (TS _ 24) }
 ']' { PT _ (TS _ 25) }
 '^' { PT _ (TS _ 26) }
 'align' { PT _ (TS _ 27) }
 'bool' { PT _ (TS _ 28) }
 'break' { PT _ (TS _ 29) }
 'by' { PT _ (TS _ 30) }
 'complex' { PT _ (TS _ 31) }
 'const' { PT _ (TS _ 32) }
 'continue' { PT _ (TS _ 33) }
 'do' { PT _ (TS _ 34) }
 'false' { PT _ (TS _ 35) }
 'for' { PT _ (TS _ 36) }
 'function' { PT _ (TS _ 37) }
 'if' { PT _ (TS _ 38) }
 'imag' { PT _ (TS _ 39) }
 'in' { PT _ (TS _ 40) }
 'int' { PT _ (TS _ 41) }
 'readInt' { PT _ (TS _ 42) }
 'readReal' { PT _ (TS _ 43) }
 'real' { PT _ (TS _ 44) }
 'string' { PT _ (TS _ 45) }
 'then' { PT _ (TS _ 46) }
 'true' { PT _ (TS _ 47) }
 'uint' { PT _ (TS _ 48) }
 'var' { PT _ (TS _ 49) }
 'while' { PT _ (TS _ 50) }
 'writeInt' { PT _ (TS _ 51) }
 'writeReal' { PT _ (TS _ 52) }
 '{' { PT _ (TS _ 53) }
 '|' { PT _ (TS _ 54) }
 '||' { PT _ (TS _ 55) }
 '}' { PT _ (TS _ 56) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_err    { _ }


%%

Ident   : L_ident  { $$ = ((Ident $1)); }
Integer : L_integ  { $$ = ((read ( $1)) :: Integer); }
Double  : L_doubl  { $$ = ((read ( $1)) :: Double); }

Boolean : 'true' { $$ = Boolean_true }
  | 'false' { $$ = Boolean_false }


Program : ListStmt { $$ = Prog $1 }


Stmt : LExpr Assignment_op RExpr ';' { $$ = Assgn $1 $2 $3 }
  | StmtCondition { $$ = Cond $1 }
  | StmtWhile { $$ = While $1 }
  | StmtDo { $$ = Do $1 }
  | StmtFor { $$ = For $1 }
  | StmtJump ';' { $$ = Jump $1 }
  | StmtWrite ';' { $$ = Write $1 }
  | StmtRead ';' { $$ = Read $1 }
  | StmtVar ';' { $$ = VarD $1 }
  | DefFunc { $$ = DFunc $1 }
  | CallFunc { $$ = CFunc $1 }


ListStmt : Stmt { $$ = (:[]) $1 }
  | Stmt ListStmt { $$ = (:) $1 $2 }

LExpr : Ident { $$ = Id $1 }
  

RExpr : RExpr 'by' RExpr2 { $$ = Eby $1 $3 }
  | RExpr '#' RExpr2 { $$ = Ecount $1 $3 }
  | RExpr 'align' RExpr2 { $$ = Ealign $1 $3 }
  | RExpr1 { $$ = $1 }

RExpr2 : RExpr2 '||' RExpr3 { $$ = Elor $1 $3 }
  | RExpr3 { $$ = $1 }

RExpr3 : RExpr3 '&&' RExpr4 { $$ = Eland $1 $3 }
  | RExpr4 { $$ = $1 }

RExpr4 : RExpr4 '==' RExpr5 { $$ = Eeq $1 $3 }
  | RExpr4 '!=' RExpr5 { $$ = Eneq $1 $3 }
  | RExpr5 { $$ = $1 }

RExpr5 : RExpr5 '<=' RExpr6 { $$ = Eleq $1 $3 }
  | RExpr5 '>=' RExpr6 { $$ = Egeq $1 $3 }
  | RExpr5 '<' RExpr6 { $$ = El $1 $3 }
  | RExpr5 '>' RExpr6 { $$ = Eg $1 $3 }
  | RExpr6 { $$ = $1 }

RExpr6 : RExpr6 '..' RExpr7 { $$ = Erange $1 $3 }
  | RExpr7 { $$ = $1 }

RExpr7 : RExpr7 '+' RExpr8 { $$ = Eadd $1 $3 }
  | RExpr7 '-' RExpr8 { $$ = Esub $1 $3 }
  | RExpr8 { $$ = $1 }

RExpr8 : RExpr8 '|' RExpr9 { $$ = Ebitor $1 $3 }
  | RExpr9 { $$ = $1 }

RExpr9 : RExpr9 '^' RExpr10 { $$ = Ebitxor $1 $3 }
  | RExpr10 { $$ = $1 }

RExpr10 : RExpr10 '&' RExpr11 { $$ = Ebitand $1 $3 }
  | RExpr11 { $$ = $1 }

RExpr11 : RExpr11 '<<' RExpr12 { $$ = Eleft $1 $3 }
  | RExpr11 '>>' RExpr12 { $$ = Eright $1 $3 }
  | RExpr12 { $$ = $1 }

RExpr12 : '+' RExpr12 { $$ = Eupos $2 }
  | '-' RExpr12 { $$ = Euneg $2 }
  | RExpr13 { $$ = $1 }

RExpr13 : RExpr13 '*' RExpr14 { $$ = Emul $1 $3 }
  | RExpr13 '/' RExpr14 { $$ =  $$ =Ediv $1 $3 }
  | RExpr13 '%' RExpr14 { $$ = $$ = Emod $1 $3 }
  | RExpr14 { $$ = $1 }

RExpr20 : Constant { $$ = Econs $1 }
  | RExpr21 { $$ = $1 }

RExpr21 : LExpr { $$ = LExprR $1 }
  | '(' RExpr ')' { $$ = $2 }


RExpr1 : RExpr2 { $$ = $1 }


RExpr14 : RExpr15 { $$ = $1 }


RExpr15 : RExpr16 { $$ = $1 }


RExpr16 : RExpr17 { $$ = $1 }


RExpr17 : RExpr18 { $$ = $1 }


RExpr18 : RExpr19 { $$ = $1 }

RExpr19 : RExpr20 { $$ = $1 }

Assignment_op : '=' { $$ = AssgnBase }

StmtWrite : 'writeInt' '(' Integer ')' { $$ = WriteInt $3 }
  | 'writeReal' '(' Double ')' { $$ = WriteReal $3 }


StmtRead : 'readInt' '(' Integer ')' { $$ = ReadInt $3 }
  | 'readReal' '(' Double ')' { $$ = ReadReal $3 }


StmtCondition : 'if' RExpr 'then' Stmt { $$ = If1 $2 $4 }
  | 'if' '(' RExpr ')' '{' ListStmt '}' { $$ = If2 $3 $6 }


StmtWhile : 'while' RExpr 'do' Stmt { $$ = WhileDo $2 $4 }


StmtDo : 'do' '{' ListStmt '}' 'while' RExpr ';' { $$ = SDo $3 $6 } 

StmtFor : 'for' RExpr 'in' Aggr 'do' '{' ListStmt '}' { $$ = SForDo $2 $4 $7 } 


Aggr : Constant '..' Constant { $$ = ForAggr $1 $3 } 


StmtJump : 'break' { $$ = Break } 
  | 'continue' { $$ = Continue }


Param : RExpr20 { $$ = Pval $1 } 
  | '*' RExpr { $$ = Pref $2 }


Constant : Integer { $$ = Int $1 } 


StmtVar : 'var' ListBlockVar { $$ = SVarBlock $2 } 
  | 'const' Ident ':' TypeSpec '=' RExpr { $$ = SVarCon $2 $4 $6 }


BlockVar : Ident ':' TypeSpec '=' RExpr { $$ = SBlockVar $1 $3 $5 } 


DefFunc : 'function' Ident '(' ListArg ')' '{' ListStmt '}' { $$ = SDefFunc $2 $4 $7 } 


CallFunc : Ident '(' ListRExpr ')' ';' { $$ = SCallFunc $1 $3 } 


Arg : Ident ':' TypeSpec { $$ = SArg $1 $3 } 


TypeSpec : BasicType { $$ = BasTyp $1 } 


BasicType : 'bool' { $$ = BasicType_bool } 
  | 'uint' { $$ = BasicType_uint }
  | 'int' { $$ = BasicType_int }
  | 'real' { $$ = BasicType_real }
  | 'imag' { $$ = BasicType_imag }
  | 'complex' { $$ = BasicType_complex }
  | 'string' { $$ = BasicType_string }


ListRExpr : {- empty -} { $$ = [] } 
  | RExpr { $$ = (:[]) $1 }
  | RExpr ',' ListRExpr { $$ = (:) $1 $3 }


ListBlockVar : {- empty -} { $$ = [] } 
  | BlockVar { $$ = (:[]) $1 }
  | BlockVar ',' ListBlockVar { $$ = (:) $1 $3 }


ListArg : {- empty -} { $$ = [] } 
  | Arg { $$ = (:[]) $1 }
  | Arg ',' ListArg { $$ = (:) $1 $3 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

