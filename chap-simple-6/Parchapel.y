-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Parchapel where
import Abschapel
import Lexchapel
import ErrM
import Envchapel
}

%attributetype    {MyAttribute a}
%attribute parsetree  {a}
%attribute tip        {Type}      -- tipo nodo
%attribute err        {String}    -- errore
%attribute addr       {String}
%attribute envIn      {[Env]}    --contiene l'environment per le variabili in input ad un nodo
%attribute envOut     {[Env]}    --contiene l'environment per le variabili in output da un nodo

%name pProgram Program

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token 
 '(' { PT _ (TS _ 1) }
 ')' { PT _ (TS _ 2) }
 '+' { PT _ (TS _ 3) }
 ',' { PT _ (TS _ 4) }
 '..' { PT _ (TS _ 5) }
 '/' { PT _ (TS _ 6) }
 ':' { PT _ (TS _ 7) }
 ';' { PT _ (TS _ 8) }
 '=' { PT _ (TS _ 9) }
 '==' { PT _ (TS _ 10) }
 '>' { PT _ (TS _ 11) }
 'boolean' { PT _ (TS _ 12) }
 'char' { PT _ (TS _ 13) }
 'do' { PT _ (TS _ 14) }
 'false' { PT _ (TS _ 15) }
 'for' { PT _ (TS _ 16) }
 'if' { PT _ (TS _ 17) }
 'in' { PT _ (TS _ 18) }
 'int' { PT _ (TS _ 19) }
 'real' { PT _ (TS _ 20) }
 'string' { PT _ (TS _ 21) }
 'then' { PT _ (TS _ 22) }
 'true' { PT _ (TS _ 23) }
 'var' { PT _ (TS _ 24) }
 'while' { PT _ (TS _ 25) }
 '{' { PT _ (TS _ 26) }
 '}' { PT _ (TS _ 27) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_quoted { PT _ (TL $$) }
L_Iden { PT _ (T_Iden $$) }
L_err    { _ }


%%

Integer : L_integ   { $$ = ((read ( $1)) :: Integer); }
Double  : L_doubl   { $$ = ((read ( $1)) :: Double); }
Char    : L_charac  { $$ = ((read ( $1)) :: Char); }
String  : L_quoted  { $$ = ($1); }
Iden    : L_Iden    { $$ = (Iden ($1));}

Program : ListStmt  { $$        = RProg $1 ;
                      $$.tip    = TypeVoid ;
                      $$.envIn  = [] ;
                      $1.envIn  = $$.envIn ;
                      $$.envOut = $1.envOut ;
                    } 

Stmt : LExpr '=' RExpr  { $$        = RAssign $1 $3 ;
                        $$.tip    = TypeVoid ;
                        $1.envIn  = $$.envIn ;
                        $$.envOut = $$.envIn ;
                        $$.err    = (checkDefVar $1.tip $3.tip) ;
                        where ( 
                          if ($1.tip == VarNotDec)
                            then (Bad $ (prntErrNotDec $1))
                            else (   
                              if ($$.err == "")
                                then (Ok())
                                else (Bad $ (prntErrAss $2 $1.tip $3.tip))
                            )
                        ) ;
                      } 
  | StmtVar { $$        = RDecVar $1 ;
              $1.envIn  = $$.envIn ;
              $$.envOut = $1.envOut ;
  }
  | StmtCondition { 
    $$  = Cond $1 ;
    $1.envIn = $$.envIn ;
    $$.envOut = $1.envOut ;
  }
  | StmtWhile { 
  	$$ = While $1  ;
    $1.envIn = $$.envIn ;
    $$.envOut = $1.envOut ;
  }
  | StmtFor { 
  	$$ = For $1 ;
    $1.envIn = $$.envIn ;
    $$.envOut = $1.envOut ;
  }

BasicType 
  : Integer   { $$ = RInt $1 ;
                $$.tip = RTypeInt ;
                $$.err = "" ;
                $$.addr = show $1 ;
              } 
  | Double    { $$ = RFloat $1 ;
                $$.tip = RTypeFloat ;
                $$.err = "" ;
                $$.addr = show $1 ;
              } 
  | Char      { $$ = RChar $1 ;
                $$.tip = RTypeChar ;
              }
  | String    { $$ = RString $1 ;
                $$.tip = RTypeString ;
              }
  | Boolean   { $$ = RBoolean $1 ;
                $$.tip = RTypeBool ;
              }


LExpr : Iden { $$      = RLExpr $1 ;
              $$.envOut = $$.envIn ; 
              $$.tip  = (getVarTip $$.envIn $1) ; 
              where ( if ($$.tip == VarNotDec)
                        then (Bad $ (prntErrNotDec $1))
                        else (Ok())
              ) ;
            }   

RExpr : RExpr '+' RExpr { $$      = RAdd $1 $3 ;
                      $$.tip  = $1.tip ;
                      $$.err  = (checkEqualType $1.tip $3.tip) ;
                      where ( 
                        if ($$.err == "") 
                          then (Ok())
                          else (Bad $ (prntErrAdd $2 ))
                      ) ;
                    }  
  | RExpr '>' RExpr { 
  	$$ = RGre $1 $3 ;
    $$.tip = RTypeBool ;
  	$1.envIn = $$.envIn ;
    $3.envIn = $$.envIn ;
    $$.envOut = $$.envIn ;
    $$.err  = (checkEqualType $1.tip $3.tip) ;
    where ( 
      if ($$.err == "") 
        then (Ok())
        else (
          if ($1.tip == VarNotDec) 
            then Bad $ (prntErrNotDec $1 )
            else (
              if ($3.tip == VarNotDec) 
                then Bad $ (prntErrNotDec $3 )
                else Bad $ (prntErrComp $2 )
            )
        )
    ) ;
  }
  | RExpr '/' RExpr { $$      =RDiv $1 $3 }
  | RExpr '==' RExpr { 
    $$ = RComp $1 $3 ;
    $$.tip = RTypeBool ;
    $1.envIn = $$.envIn ;
    $3.envIn = $$.envIn ;
    $$.envOut = $$.envIn ;
    $$.err  = (checkEqualType $1.tip $3.tip) ;
    where ( 
      if ($$.err == "") 
        then (Ok())
        else (
          if ($1.tip == VarNotDec) 
            then Bad $ (prntErrNotDec $1 )
            else (
              if ($3.tip == VarNotDec) 
                then Bad $ (prntErrNotDec $3 )
                else Bad $ (prntErrComp $2 )
            )
        )
    ) ;
  }
  | BasicType { $$      = RElem $1 ;
                $$.tip  = $1.tip ;
              }
  | LExpr { 
    $$ = LExprR $1 ;
    $$.tip = $1.tip ;  
    $1.envIn = $$.envIn ; 
    $$.envOut = $1.envOut ; 
  }

StmtVar : 'var' ListBlockVar { 
                              $$ = RVarBlock $2 ; 
                              $2.envIn = $$.envIn ;
                              $$.envOut = $2.envOut ; 
                              } 

BlockVar : Iden ':' Type '=' RExpr  { 
  $$          = RBlockVar $1 $3 $5 ;
  $$.envOut   = (insVarEnv (Var $1 $3.tip) $$.envIn);
  $$.err      = (checkDefVar $3 $5.tip) ;
  where ( if ($$.err == "")   
    then (Ok())
    else (Bad $ (prntErrDiffType $2))
    ) ;
  }  


StmtCondition : 'if' RExpr 'then' Stmt { 
    $$ = If1 $2 $4 ;
    $2.envIn = $$.envIn ;
    $4.envIn = $$.envIn ;
    $$.envOut = $4.envOut ;
    $$.err 	= (checkEqualType $2.tip RTypeBool) ;
	where ( if ($$.err == "")   
		then (Ok())
		else (Bad $ (prntErrCondNotBool $1))
	) ;
  } 
  | 'if' '(' RExpr ')' '{' ListStmt '}' {
  	$$ = If2 $3 $6 ;
    $3.envIn = $$.envIn ;
    $6.envIn = $$.envIn ;
    $$.envOut = $6.envOut ;
    $$.err 	= (checkEqualType $3.tip RTypeBool) ;
	where ( if ($$.err == "")   
		then (Ok())
		else (Bad $ (prntErrCondNotBool $1))
	) ;
  }


StmtWhile : 'while' RExpr 'do' Stmt {	
	$$ =  WhileDo $2 $4 ;
    $2.envIn = $$.envIn ;
    $4.envIn = $$.envIn ;
    $$.envOut = $4.envOut ;
    $$.err 	= (checkEqualType $2.tip RTypeBool) ;
	where ( if ($$.err == "")   
		then (Ok())
		else (Bad $ (prntErrCondNotBool $1))
	) ;
	} 
  | 'while' RExpr '{' ListStmt '}' {
  	$$ =  WhileDoS $2 $4 ;
    $2.envIn = $$.envIn ;
    $4.envIn = $$.envIn ;
    $$.envOut = $4.envOut ;
    $$.err 	= (checkEqualType $2.tip RTypeBool) ;
	where ( if ($$.err == "")   
		then (Ok())
		else (Bad $ (prntErrCondNotBool $1))
	) ;
  }

-- inserisco nel contesto di ListStmt l'iteratore
StmtFor : 'for' Iden 'in' Aggr '{' ListStmt '}' { 
	$$ = SForDoBloc $2 $4 $6 ;
    $2.envIn = $$.envIn ;    
    $6.envIn = (insVarEnv (Var $2 RTypeInt) $$.envIn);
    $$.envOut = $$.envIn;
} 

Aggr : Integer '..' Integer { $$ = ForAggr $1 $3 } 

Boolean : 'true' { 
    $$ = RTrue ;
  } 
  | 'false' { 
    $$ = RFalse ;
  }


Type : 'int' { $$ = RTypeInt ; $$.tip = $$ ;} 
  | 'real' { $$ = RTypeFloat ; $$.tip = $$ ; }
  | 'char' { $$ = RTypeChar ; $$.tip = $$ ; }
  | 'string' { $$ = RTypeString ; $$.tip = $$ ; }
  | 'boolean' { $$ = RTypeBool ; $$.tip = $$ ;}

ListBlockVar 
  : {- empty -}               { $$ = [] ; $$.envOut = $$.envIn } 
  | BlockVar                  { $$ = (:[]) $1 ; 
                                $$.envOut = $1.envOut ;
                                $1.envIn = $$.envIn ;
                                }
  | BlockVar ',' ListBlockVar { $$ = (:) $1 $3 ; 
                                $$.envOut = $3.envOut ; 
                                $1.envIn = $$.envIn ;
                                $3.envIn = $1.envOut ;
                                }

ListStmt 
  : {- empty -} { $$ = ([]) ; 
                  $$.envOut = $$.envIn ;
                } 
  | Stmt              { $$ = ((:[]) $1) ;
                        $1.envIn  = $$.envIn ;
                        $$.envOut = $1.envOut ;
                      }
  | Stmt ';' ListStmt { $$ = ((:) $1 $3) ; 
                        $1.envIn = $$.envIn ;
                        $3.envIn = $1.envOut ;
                        $$.envOut = $3.envOut ;
                      }

{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

